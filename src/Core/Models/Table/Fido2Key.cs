using System;
using System.Collections.Generic;
using Fido2NetLib.Objects;
using Newtonsoft.Json;

namespace Bit.Core.Models.Table
{
    /// <summary>
    /// Class of FIDO2 Key, here is data saved on the DB about
    /// the keys that user contains.
    /// </summary>
    public class Fido2Key : ITableObject<Guid>
    {
        // ID unique of FIDO2 key
        public Guid Id { get; set; }
        // ID of the user, to say that this FIDO2 Key belongs to this user id.
        public Guid UserId { get; set; }
        // Name of FIDO2 Key.
        public string Name { get; set; }
        // FIDO2 Key id generated by the FIDO2 client.
        public string CredentialId { get; set; }
        // Public Key generated by the FIDO2 client.
        public string PublicKey { get; set; }
        // The counter necessary for checking the signature.
        public long SignatureCounter { get; set; }
        // The type of key, for now only exists PublicKey.
        public PublicKeyCredentialType CredentialType { get; set; }
        // The type of key used, if is platform (fingerprint, PIN) or cross-platform (Yubikey, NFC, Bluetooth).
        public AuthenticatorAttachment AuthenticatorType { get; set; }
        // Same as "AuthenticatorType", the only differences is that specify where the key is from ["internal", "usb", "blu", "nfc"].
        public string Transports { get; set; }
        // Field that tells us if it is compromised, and for not to use it in authentication.
        public bool Compromised { get; set; }
        // When FIDO2 Key was created
        public DateTime CreationDate { get; internal set; } = DateTime.UtcNow;
        public void SetNewId()
        {
            Id = Utilities.CoreHelpers.GenerateComb();
        }

        /// <summary>
        /// To get Transports Type in Array, ["internal", "usb", "blu", "nfc"]
        /// </summary>
        internal List<AuthenticatorTransport> getTransportsEnum()
        {
            return JsonConvert.DeserializeObject<List<AuthenticatorTransport>>(Transports);
        }

        /// <summary>
        /// To get Credential Type in string, ["public-key"]
        /// </summary>
        internal string getCredentialTypeString()
        {
            switch (this.CredentialType)
            {
                case PublicKeyCredentialType.PublicKey:
                    return "public-key";
            }
            return "";
        }

        /// <summary>
        /// To get Authenticator Type in string, ["Platform", "Cross-Platform"]
        /// </summary>
        internal string getAuthenticatorTypeString()
        {
            switch (this.AuthenticatorType)
            {
                case AuthenticatorAttachment.Platform:
                    return "Platform";
                case AuthenticatorAttachment.CrossPlatform:
                    return "Cross-Platform";
            }
            return "";
        }

        /// <summary>
        /// To serialize Transports Type to string.
        /// </summary>
        internal static string getTransportsStringByAuthenticatorType(AuthenticatorAttachment? AuthenticatorType)
        {
            switch (AuthenticatorType)
            {
                case AuthenticatorAttachment.Platform:
                    return JsonConvert.SerializeObject(new List<AuthenticatorTransport> { AuthenticatorTransport.Internal });
                case AuthenticatorAttachment.CrossPlatform:
                    return JsonConvert.SerializeObject(new List<AuthenticatorTransport> { AuthenticatorTransport.Ble, AuthenticatorTransport.Nfc, AuthenticatorTransport.Usb });
            }
            return "";
        }
    }
}
